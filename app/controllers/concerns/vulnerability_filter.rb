require 'securerandom'
# require 'mixpanel-ruby'

class VulnerabilityFilter
  include ErrorCode

  DEFAULT_PARAM   = ParamConfig.default  # The default parameter validator
  CSRF_PARAM      = ParamConfig.csrf     # The CSRF parameter validator
  CSRF_TOKEN      = "csrf_token"
  CSRF_LIST_SIZE  = 10
  CSRF_HEADER     = Constants::CSRF_HEADER
  CSRF_COOKIE     = Constants::CSRF_COOKIE
  CSRF_TOKENS     = Constants::CSRF_TOKENS

  # Make it a class variable, there shall be only one
  # for the system
  DOMAIN_REGEX    = /^http([s]?):\/\/([^\/:]*[\.]*)([:][\d]*)?\/(.*)$/i
  PATH_REGEX      = Constants::PATH_REGEX


  def self.before(controller)
      # Force no cache
      controller.response.headers["Cache-Control"] = "no-cache, must-revalidate, no-store"

      p = get_path(controller)
      if (ENV['CORS_ENABLED'] == "true")
        controller.response.headers["Access-Control-Allow-Origin"] = "*"
        controller.response.headers["Access-Control-Allow-Methods"] = 'POST, GET, OPTIONS';
      end

      # The locale
      I18n.locale = controller.lang

      # Log the navigation
      log_nav(controller)

      # Clear the breadcrumb
      clear_bc(controller)

      # Black listed
      return nil if (validate_black_listed(controller).nil?)

      # Validate the ?
      return nil if (validate_no_question_mark(controller).nil?)

      # Validate the pid
      return nil if (validate_pid(controller).nil?)

      # Validate the params for denial of service attacks
      return nil if (validate_param_values(controller).nil?)

      # Validate the param values for special chars
      return nil if (validate_param_special_chars(controller).nil?)

      # Validate the api key, a valid api key skips the rest
      return true if (validate_api_key(controller) == true)

      # Validate the csrf token
      # return nil if (validate_csrf(controller).nil?)

      # Add the click jacking header
      add_security_headers(controller)
  end

  # Keep the navigation in the session
  # mostly for error reporting
  def self.log_nav(controller)
    return if (controller.request.url.ends_with?("/security/ping"))

    if (controller.has_session?)
      controller.session[:nav] = [] if (controller.session[:nav].nil?)
      m = {:url=>controller.request.url,
           :method=>controller.request.method,
           :pid=>controller.request.params[:pid],
           :oid=>controller.request.params[:oid],
           :ot=>controller.request.params[:ot]}
      controller.session[:nav].unshift m
      controller.session[:nav].pop if controller.session[:nav].size > 10
    end
  end

  # Clear the bread crumbs if we are navigating to it
  def self.clear_bc(controller)
    if (controller.session['adn_breadcrumbs'].present? &&
        controller.session['adn_breadcrumbs'][:url] == controller.request.url)
      controller.session['adn_breadcrumbs'] = nil

    end
  end

  # Return nil if the user or IP is black listed
  def self.validate_black_listed controller
    p = get_path(controller)
    return true if (p.start_with?("/sjs/consts"))  # Do not backlist this

    # if (BlackList.is_black_listed?(controller))
    #   controller.logger.info "User is black listed"
    #   controller.logger.info "IP: #{controller.request.ip}, Email: #{controller.current_user_email}"
    #   controller.logger.info "Url: #{controller.request.url}"
    #   respond_forbidden controller
    #   return nil
    # end
    true
  end

  def self.log_invalid_path(controller)
    msg = "#{ErrorCode::S010} #{controller.request.url}"
    BadRequest.record(controller, msg)
    controller.respond_forbidden
    return nil
  end

  # There should be no ? in the QS
  # Return nil in validation failure
  def self.validate_no_question_mark(controller)

    # The facebook wh receives ?
    p = get_path(controller)
    return true if (p.start_with?("/fb/webhook") ||
                    p.start_with?("/sjs/consts") ||
                    p.start_with?("/iard") ||
                    p.start_with?("/dl/wh") ||
                    p.start_with?("/email_processor") ||
                    p.start_with?("/operation/cal") ||
                    p.start_with?("/security/login") ||
                    p.start_with?("/security/logout") ||
                    p.start_with?("/oauth") ||
                    p.start_with?("/auth") ||
                    p.start_with?("/insurance/broker/firms") ||
                    p.start_with?("/insurance/broker/agas") ||
                    p.start_with?("/insurance/insurer/list") ||
                    p.start_with?("/lib/api.md") ||
                    p.start_with?("/insurance/brokerj/broker_clientsj") ||
                    p.start_with?("/insurance/broker/all_brokers") ||
                    p.start_with?("/insurance/txj/tx_records") ||
                    p.start_with?("/invest/asumj")
                  )

    # Assert other urls
    if (controller.request.url.include? '?')
      controller.logger.error "IP: #{controller.request.ip}, Email: #{controller.current_user_email}"
      controller.logger.error "Url: #{controller.request.url}"
      msg = "Question mark found in query string: #{controller.request.url}"
      controller.logger.error msg
      BadRequest.record controller, msg
      respond_forbidden controller
      return nil
    end
    true
  end

  # The person
  #  - must be a client of the advisor, or
  #  - the user is an admin
  def self.validate_pid(controller)
    pid = controller.request.params[:pid]
    return true if (pid.blank?)
    p = get_path(controller)
    return true if (p.start_with?("/m/sec/auth"))

    # There's a pid, no session
    if (!controller.has_session?)
      controller.session[:return_url] = controller.request.url
      controller.redirect_to "/security/login"
      return nil
    end

    # Validate the existence
    begin
      p = Person.find(pid)
    rescue
      s = "unauthorized, person not found for pid: #{pid}"
      controller.email_error(s) if (ENV['RAILS_ENV'] != 'development')
      raise "unauthorized"
    end

    # Admin, any person is ok
    return true if(controller.is_admin? || controller.is_mga? || controller.is_iard_admin?)

    if (!controller.has_session?)
      controller.session[:return_url] = controller.request.url
      controller.redirect_to "/security/login"
    elsif(p.id == controller.current_user_id)
      return true # a user viewing self

    elsif(access_level(controller.current_user, p, controller) > 0)
      return true
    end
    # We should not be here
    raise "unauthorized access, trying to access the following person: #{p.id}"
  end

  def self.access_level(current_user, person, controller)
    if (current_user.is_advisor_lead?)
      return 100 if (current_user.rels.where(:person_to=>person, :kind=>Person::Relationship::CLIENT).size > 0)
      return 100 if (current_user.rels.where(:person_to=>person, :kind=>Person::Relationship::STAFF).size > 0)

    elsif (current_user.is_advisor?)
      # full access to clients
      a = current_user.staff_advisor
      return 100 if (a.rels.where(:person_to=>person, :kind=>Person::Relationship::CLIENT).size > 0)
      return 100 if (person.advisor == a)
    elsif (current_user.has_spouse? && current_user.spouse.id.to_s == person.id.to_s)
      return 50  # spouse access ?!?
    elsif(current_user.is_parent_of?(person.id))
      return 100  # full access
    end
    return 0
  end

  # Adds the security headers
  def self.add_security_headers(controller)
    controller.response.headers["X-Frame-Options"] = "DENY"
    controller.response.headers["X-Content-Type-Options"] = "nosniff"
    controller.response.headers["X-XSS-Protection"] = "1; mode=block"
    controller.response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubdomains"

    csp_map = {
      :default_src => "default-src 'self' code.jquery.com",
      :img_src => "img-src 'self' www.facebook.com data:",  # The load image plugin generates Base64 images
      :script_src => "script-src 'self' code.jquery.com connect.facebook.net www.gstatic.com",
      :child_src => "frame-src 'self'",
      :form_action => "form-action 'self'",
      :style_src => "style-src 'self' 'unsafe-inline' fonts.googleapis.com",
      :report_uri => "report-uri /security/log_content_sec"
    }

    p = get_path(controller)
    csp_map[:script_src] = "script-src 'self' 'unsafe-inline'" if (p.start_with?("/task/task/notes") || p.start_with?("/note/show"))
    csp = ""
    csp_map.each do |k,v|
      vp = v
      # The file docs page needs eval for the templating...
      # or popup
      if (k == :script_src)
        p = get_path(controller)
        if (["/filez/docs", "/filez/doc_tree", "/task/obj_tasks", "/task/my"].include?(p))
          vp = "#{vp} 'unsafe-eval'"
        end
      end
      csp = "#{csp} #{vp}; "
    end

    header = (ENV['ADN_CSP'] == "true") ? "Content-Security-Policy" : "Content-Security-Policy-Report-Only"
    controller.response.headers[header] = csp

  end

  # The API key
  def self.validate_api_key(controller)
    params = controller.params
    if (params[:apikey].present?)
      p = Person.where(:api_key=>params[:apikey]).first
      return nil if p.nil?
      controller.logger.info "---> Authenticating user with API key: #{p.email}"
      start_mobile_session controller, p
      return true
    end
    nil
  end

  # The CSRF validation
  def self.validate_csrf(controller)

    return true if (controller.request.get?)

    # The facebook doesn't use csrf
    return true if get_path(controller).start_with?("/fb/webhook")
    return true if get_path(controller).start_with?("/dl/wh")
    return true if get_path(controller).start_with?("/security/log_js_error")

    # No CSRF validation for mobile, at least for now
    return true if get_path(controller).start_with?("/m/")
    return true if get_path(controller).start_with?("/404")
    return true if get_path(controller).start_with?("/500")

    # No CSRF for error logging
    return true if (["/security/log_content_sec"].include?(get_path(controller)))

    # Attempt the AJAX header validation
    h = validate_csrf_header(controller)
    # return nil if h.nil?
    # return true if h == true

    params = controller.params
    # The token must be present in the POST
    tok = params[CSRF_TOKEN]
    if (tok.nil?)
      controller.logger.error "#{S002} [#{controller.request.url}]"
      # respond_forbidden controller
      # return nil
    end
    # The token list must exist if there's a post
    tokens = controller.session[CSRF_TOKENS]
    if (tokens.nil?)
      controller.logger.error "#{S003} [#{controller.request.url}]"
      # respond_forbidden controller
      # return nil
    end

    # Validate the token
    if (!tokens.include?(tok))
      controller.logger.error "#{S004} [#{controller.request.url}]"
      # respond_forbidden controller
      # return nil
    else
      # Do not delete the token for now
      # This disables the back button
      # tokens.delete tok
    end

    true
  end

  # Validates the CSRF header against the cookie
  # false, no header was found, no ajax
  # true, validation ok
  # nil?: validation failure
  def self.validate_csrf_header(controller)
    h = controller.request.headers["HTTP_CSRF_HEADER"]
    return false if (h.nil?)  # It ain't an AJAX call if no header
    s = controller.session[Constants::CSRF_HEADER]
    if (s.nil? || s != h)
      controller.logger.error "#{S014}: s=#{s} h=#{h}"
      # respond_forbidden controller
      # return nil
    elsif (s.present? || s == h)
      return true
    end
    # No validation was performed
    false
  end

  # Validate the parameters against the url_config configuration
  def self.validate_param_values(controller)
    url = get_path controller

    # Look if there's a config for the url/field
    # Otherwise consider max length to be 100 chars
    url_config = UrlConfig::URLS[url]
    params_config = url_config["params"] if url_config.present?

    # Validate the parameters one by one
    controller.params.each do |key, value|
      next if (value.class != String)  # The session comes in as a parameter in rails 5
      param_config = params_config[key] if params_config.present?
      begin
        if (key == CSRF_TOKEN)
          CSRF_PARAM.validate(key,value,controller)

        elsif param_config.present?
          param_config.validate(key, value, controller)

        elsif (controller.params[key].class == Array)
          # It's a JQuery multi-file upload
          # Validate it later

        elsif (controller.params[key].class != NilClass &&
               controller.params[key].class != String &&
               controller.params[key].class == ActionDispatch::Http::UploadedFile)    # It's a file upload

          file_data = controller.params[key].tempfile
          controller.logger.info "File upload size: #{File.stat(controller.params[key].tempfile).size}"
        else
          DEFAULT_PARAM.validate(key, value, controller)
        end
      rescue Exception => e
        m = "Error for parameter: #{key}"
        controller.email_error(m)
        controller.logger.error(m)
        controller.logger.error e.backtrace
        controller.logger.error e.message
        controller.logger.error ErrorCode::S001
        respond_forbidden controller
        return nil
      end
    end

    true
  end

  # Validate the parameters against the url_config configuration
  def self.validate_param_special_chars(controller)
    # return if (get_path(controller) == "/m/pic")
    # return if (get_path(controller) == "/security/log_js_error")

    # # Validate the parameters one by one
    # controller.params.each do |key,value|
    #   next if (controller.params[key].class != String)
    #   if (/[\\;`$]/.match(value).present?)
    #     controller.logger.error ErrorCode::S008
    #     controller.logger.info "IP: #{controller.request.ip}, Email: #{controller.current_user_email}"
    #     controller.logger.info "Url: #{controller.request.url}"
    #     controller.logger.info "Param: #{key}, value: #{value}"
    #     controller.logger.info "Black listing user"
    #     BadRequest.record_unauth controller, "Invalid character in: #{value}"
    #     respond_forbidden controller
    #     return nil
    #   end
    # end
    true
  end

  # Return the pub/contact part of the url
  def self.get_path(controller)
    u = controller.request.url
    g = u.scan Constants::PATH_REGEX
    return "" if g.size == 0
    return "" if g[0].size == 0
    p = g[0][1]

    # p looks like /a/b/12345
    g2 = p.scan(/([a-z][^\/]*)/)
    return "" if g2.size == 0
    return "" if g2[0].size == 0
    if g2.size == 1
      # return /a
      return "/#{g2[0][0]}"
    elsif g2.size == 2
      return "/#{g2[0][0]}/#{g2[1][0]}"
    elsif g2.size >= 3
      # return /a/b/c
      return "/#{g2[0][0]}/#{g2[1][0]}/#{g2[2][0]}"
    end
  end

  # Responds with a 403 error code
  def self.respond_forbidden(controller)
    controller.render :status => :forbidden, :plain => "accès non authorisé. IP: #{controller.request.ip}"
  end

  # Creates a CSRF token
  def self.make_csrf_token_for_session(controller)
    controller.session[CSRF_TOKENS] = [] if controller.session[CSRF_TOKENS].nil?
    tok = SecureRandom.hex(Constants::CSRF_SIZE)
    controller.session[CSRF_TOKENS] << tok
    controller.session[CSRF_TOKENS].delete_at(0) if (controller.session[CSRF_TOKENS].size > CSRF_LIST_SIZE)
    tok
  end

  # Starts a mobile session upon API key validation
  def self.start_mobile_session controller, person
    controller.reset_session
    controller.session[:user] = person
    controller.session[:user_id] = person.id
  end

end
